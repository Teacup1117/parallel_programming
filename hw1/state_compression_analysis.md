# 推箱子問題狀態壓縮優化策略

## 問題分析
原始實現將整個地圖和玩家位置都儲存在狀態中，這會導致：
1. **大量冗余狀態**：玩家在相同箱子配置下的不同位置被當作不同狀態
2. **記憶體浪費**：每個狀態都儲存完整地圖
3. **搜尋效率低**：需要探索過多的無用狀態

## 主要優化策略

### 1. 基礎壓縮：箱子位置 + 玩家位置
```cpp
struct CompressedState {
    set<pair<int, int>> boxes;  // 只記錄箱子位置
    pair<int, int> player_pos;  // 玩家位置
};
```
**優點：**
- 不再儲存完整地圖
- 狀態大小固定
- 哈希和比較更快

**缺點：**
- 仍然區分玩家的具體位置

### 2. 進階壓縮：箱子位置 + 玩家可達區域
```cpp
struct UltraCompressedState {
    set<pair<int, int>> boxes;          // 箱子位置
    set<pair<int, int>> reachable_area; // 玩家可達區域
};
```
**優點：**
- 將玩家在同一連通區域的所有位置合併為一個狀態
- 大幅減少狀態數量

**缺點：**
- 可達區域集合仍然較大
- 哈希計算較慢

### 3. 終極壓縮：箱子位置 + 連通區域ID
```cpp
struct UltraCompressedState {
    vector<pair<int, int>> boxes;  // 箱子位置（有序）
    int connected_component_id;    // 玩家連通區域的唯一標識
};
```
**優點：**
- 將玩家可達區域用單一整數表示
- 最小的狀態表示
- 最快的哈希和比較

## 核心實現技術

### 1. 連通區域計算
```cpp
int get_connected_component_id(const pair<int, int>& player_pos, 
                              const vector<pair<int, int>>& boxes) {
    // BFS 找到玩家可達的所有位置
    // 將位置集合轉換為唯一的哈希ID
}
```

### 2. 狀態轉移優化
```cpp
vector<pair<UltraCompressedState, char>> get_successors(const UltraCompressedState& state) {
    // 1. 重建一個代表性的玩家位置
    // 2. 對每個箱子嘗試推動
    // 3. 檢查玩家是否能到達推箱子的位置
    // 4. 計算新狀態的連通區域ID
}
```

### 3. 玩家可達性檢查
```cpp
bool can_reach(const pair<int, int>& from, const pair<int, int>& to, 
               const vector<pair<int, int>>& boxes) {
    // BFS 檢查在給定箱子配置下玩家是否能從 from 到達 to
}
```

## 效果分析

### 狀態空間縮減
- **原版**：狀態 = 地圖 × 玩家位置 ≈ O(4^(n×m))
- **基礎壓縮**：狀態 = 箱子位置 × 玩家位置 ≈ O((n×m)^k × n×m)
- **終極壓縮**：狀態 = 箱子位置 × 連通區域數 ≈ O((n×m)^k × 常數)

其中 n×m 是地圖大小，k 是箱子數量

### 性能提升
1. **記憶體使用**：從存儲完整地圖到只存儲少數幾個整數
2. **哈希效率**：從字符串哈希到整數運算
3. **狀態比較**：從字符串比較到數值比較
4. **搜尋剪枝**：大量無效的玩家移動狀態被自動合併

## 進一步優化建議

### 1. 箱子配置的對稱性檢測
如果地圖具有對稱性，可以將對稱的箱子配置視為同一狀態。

### 2. 預計算連通區域
對於所有可能的箱子配置，預先計算連通區域映射，避免運行時計算。

### 3. 增量連通區域更新
當只移動一個箱子時，可以增量更新連通區域，而不是重新計算。

### 4. 多層次狀態表示
結合不同粒度的狀態表示，在搜尋的不同階段使用不同的壓縮策略。

## 結論
通過狀態壓縮，我們成功將推箱子問題的搜尋空間從指數級降低到多項式級，同時保持了解的正確性。這種優化策略特別適用於：
- 玩家移動步數較多的遊戲
- 地圖較大但箱子數量相對較少的情況
- 需要快速找到最優解的場景

最終的終極壓縮版本在保持算法正確性的同時，實現了顯著的性能提升。
