//***********************************************************************************
// ULTIMATE OPTIMIZED Bitcoin Miner with SHA256 Midstate Caching
// çµ‚æ¥µå„ªåŒ–ç‰ˆæœ¬ - åŒ…å« SHA256 ä¸­é–“ç‹€æ…‹ç·©å­˜
//***********************************************************************************

#include <iostream>
#include <cstdio>
#include <cstring>
#include <cassert>
#include "sha256.h"

typedef struct _block
{
    unsigned int version;
    unsigned char prevhash[32];
    unsigned char merkle_root[32];
    unsigned int ntime;
    unsigned int nbits;
    unsigned int nonce;
}HashBlock;

// ä¸­é–“ç‹€æ…‹çµæ§‹
typedef struct _midstate {
    WORD h[8];        // SHA256 ä¸­é–“ç‹€æ…‹
    BYTE buffer[64];  // ç¬¬äºŒå€‹ block çš„å‰åŠéƒ¨åˆ†
    int buffer_len;   // buffer ä¸­çš„æ•¸æ“šé•·åº¦
} Midstate;

unsigned char decode(unsigned char c)
{
    switch(c)
    {
        case 'a': return 0x0a;
        case 'b': return 0x0b;
        case 'c': return 0x0c;
        case 'd': return 0x0d;
        case 'e': return 0x0e;
        case 'f': return 0x0f;
        case '0' ... '9': return c-'0';
    }
    return 0;
}

void convert_string_to_little_endian_bytes(unsigned char* out, char *in, size_t string_len)
{
    assert(string_len % 2 == 0);
    size_t s = 0;
    size_t b = string_len/2-1;
    for(s, b; s < string_len; s+=2, --b)
        out[b] = (unsigned char)(decode(in[s])<<4) + decode(in[s+1]);
}

void print_hex(unsigned char* hex, size_t len)
{
    for(int i=0;i<len;++i) printf("%02x", hex[i]);
}

void print_hex_inverse(unsigned char* hex, size_t len)
{
    for(int i=len-1;i>=0;--i) printf("%02x", hex[i]);
}

int little_endian_bit_comparison(const unsigned char *a, const unsigned char *b, size_t byte_len)
{
    for(int i=byte_len-1;i>=0;--i)
    {
        if(a[i] < b[i]) return -1;
        else if(a[i] > b[i]) return 1;
    }
    return 0;
}

void getline(char *str, size_t len, FILE *fp)
{
    int i=0;
    while( i<len && (str[i] = fgetc(fp)) != EOF && str[i++] != '\n');
    str[len-1] = '\0';
}

//=============================================================================
// å„ªåŒ–çš„ SHA256 - ä½¿ç”¨ä¸­é–“ç‹€æ…‹ç·©å­˜
//=============================================================================

// Device: å¾ä¸­é–“ç‹€æ…‹ç¹¼çºŒè¨ˆç®— SHA256
__device__ void sha256_from_midstate_device(
    SHA256 *ctx, 
    const WORD *midstate_h,
    const BYTE *remaining_data,
    size_t remaining_len,
    const WORD *k_values)
{
    // å¾©åˆ¶ä¸­é–“ç‹€æ…‹
    #pragma unroll
    for(int i = 0; i < 8; i++)
        ctx->h[i] = midstate_h[i];
    
    // æº–å‚™æœ€å¾Œä¸€å€‹ block (åŒ…å« nonce)
    BYTE m[64] = {};
    
    // è¤‡è£½å‰©é¤˜æ•¸æ“š (åŒ…å« nonce çš„ 16 bytes + padding)
    #pragma unroll
    for(int i = 0; i < remaining_len; i++)
        m[i] = remaining_data[i];
    
    // è™•ç†é€™å€‹ block
    sha256_transform_device(ctx, m, k_values);
    
    // Convert to big-endian
    #pragma unroll
    for(int i=0;i<32;i+=4)
    {
        _swap(ctx->b[i], ctx->b[i+3]);
        _swap(ctx->b[i+1], ctx->b[i+2]);
    }
}

// Device: å„ªåŒ–çš„ double SHA256ï¼Œä½¿ç”¨ä¸­é–“ç‹€æ…‹
__device__ void double_sha256_midstate_device(
    SHA256 *result,
    const WORD *midstate_h,
    const BYTE *second_chunk_template,
    unsigned int nonce,
    const WORD *k_values)
{
    // æº–å‚™åŒ…å« nonce çš„ç¬¬äºŒå€‹ chunk
    BYTE second_chunk[64];
    
    // ä½¿ç”¨å‘é‡åŒ–è¨˜æ†¶é«”è¨ªå•åŠ é€Ÿ
    uint4 *dst = (uint4*)second_chunk;
    const uint4 *src = (const uint4*)second_chunk_template;
    
    #pragma unroll
    for(int i = 0; i < 16; i++)  // 64 bytes / 4 = 16
        dst[i] = src[i];
    
    // æ’å…¥ nonce (ä½ç½® 76-79ï¼Œåœ¨ç¬¬äºŒå€‹ chunk çš„ 12-15)
    *((unsigned int*)(second_chunk + 12)) = nonce;
    
    // ç¬¬ä¸€æ¬¡ SHA256: å¾ä¸­é–“ç‹€æ…‹è¨ˆç®—
    SHA256 tmp;
    sha256_from_midstate_device(&tmp, midstate_h, second_chunk, 64, k_values);
    
    // ç¬¬äºŒæ¬¡ SHA256: å®Œæ•´è¨ˆç®—
    sha256_device(result, tmp.b, 32, k_values);
}

// Device: æ¯”è¼ƒå‡½æ•¸ (å…§è¯å„ªåŒ–)
__device__ __forceinline__ int compare_hash_target(const unsigned char *hash, const unsigned char *target)
{
    // ä½¿ç”¨å‘é‡åŒ–æ¯”è¼ƒ
    const uint4 *h = (const uint4*)hash;
    const uint4 *t = (const uint4*)target;
    
    // å¾é«˜ä½é–‹å§‹æ¯”è¼ƒ (big-endianï¼Œæ‰€ä»¥å¾å¾Œå¾€å‰)
    for(int i = 7; i >= 0; i--)
    {
        unsigned int h_val = ((unsigned int*)h)[i];
        unsigned int t_val = ((unsigned int*)t)[i];
        if(h_val < t_val) return -1;
        if(h_val > t_val) return 1;
    }
    return 0;
}

//=============================================================================
// çµ‚æ¥µå„ªåŒ– Kernel
//=============================================================================

__global__ void find_nonce_ultimate_kernel(
    const WORD *midstate_h,           // SHA256 ä¸­é–“ç‹€æ…‹ (8 å€‹ WORD)
    const BYTE *second_chunk_template, // ç¬¬äºŒå€‹ chunk æ¨¡æ¿
    const unsigned char *target_hex,
    unsigned int *found_nonce,
    int *found_flag,
    unsigned int start_nonce,
    unsigned int total_nonces)
{
    // å…±äº«è¨˜æ†¶é«”å„ªåŒ–
    __shared__ WORD shared_midstate[8];
    __shared__ BYTE shared_chunk[64];
    __shared__ unsigned char shared_target[32];
    
    // ä½¿ç”¨ warp çš„ç¬¬ä¸€å€‹ç·šç¨‹åŠ è¼‰
    if(threadIdx.x < 8)
        shared_midstate[threadIdx.x] = midstate_h[threadIdx.x];
    
    if(threadIdx.x < 16)
    {
        ((uint4*)shared_chunk)[threadIdx.x % 16] = ((uint4*)second_chunk_template)[threadIdx.x % 16];
        if(threadIdx.x < 8)
            ((uint4*)shared_target)[threadIdx.x % 8] = ((uint4*)target_hex)[threadIdx.x % 8];
    }
    
    __syncthreads();
    
    // è¨ˆç®—å…¨å±€ç·šç¨‹ ID
    unsigned int tid = blockIdx.x * blockDim.x + threadIdx.x;
    unsigned int stride = blockDim.x * gridDim.x;
    
    // æ¯å€‹ç·šç¨‹è™•ç†å¤šå€‹ nonce (å±•é–‹å¾ªç’°ä»¥æé«˜ ILP)
    for(unsigned int offset = tid; offset < total_nonces; offset += stride * 4)
    {
        // æ—©æœŸé€€å‡ºæª¢æŸ¥
        if(*found_flag) return;
        
        // è™•ç† 4 å€‹ nonce (å¾ªç’°å±•é–‹)
        #pragma unroll
        for(int i = 0; i < 4; i++)
        {
            unsigned int nonce_offset = offset + stride * i;
            if(nonce_offset >= total_nonces) break;
            
            unsigned int nonce = start_nonce + nonce_offset;
            
            // è¨ˆç®— hash
            SHA256 hash;
            double_sha256_midstate_device(&hash, shared_midstate, shared_chunk, nonce, d_k);
            
            // æ¯”è¼ƒ hash èˆ‡ target
            if(compare_hash_target(hash.b, shared_target) < 0)
            {
                // æ‰¾åˆ°è§£æ±ºæ–¹æ¡ˆï¼
                int old = atomicCAS(found_flag, 0, 1);
                if(old == 0)
                {
                    *found_nonce = nonce;
                }
                return;
            }
        }
    }
}

//=============================================================================
// CPU ç«¯å‡½æ•¸
//=============================================================================

void double_sha256(SHA256 *sha256_ctx, unsigned char *bytes, size_t len)
{
    SHA256 tmp;
    sha256(&tmp, (BYTE*)bytes, len);
    sha256(sha256_ctx, (BYTE*)&tmp, sizeof(tmp));
}

void calc_merkle_root(unsigned char *root, int tx, char **merkle_branch)
{
    int total_count = tx;
    unsigned char *raw_list = new unsigned char[total_count * 32];
    unsigned char **list = new unsigned char*[total_count];

    for(int i=0;i<total_count;++i)
    {
        list[i] = raw_list + i * 32;
        convert_string_to_little_endian_bytes(list[i], merkle_branch[i], 64);
    }

    while(total_count > 1)
    {
        int i, j;
        if(total_count % 2 == 1)
            memcpy(list[total_count], list[total_count-1], 32);
        for(i=0, j=0;i<total_count;i+=2, ++j)
            double_sha256((SHA256*)list[j], list[i], 64);
        total_count = j;
    }

    memcpy(root, list[0], 32);
    delete[] raw_list;
    delete[] list;
}

// è¨ˆç®— SHA256 ä¸­é–“ç‹€æ…‹
void compute_midstate(Midstate *ms, const HashBlock *block)
{
    // åˆå§‹åŒ– SHA256
    ms->h[0] = 0x6a09e667;
    ms->h[1] = 0xbb67ae85;
    ms->h[2] = 0x3c6ef372;
    ms->h[3] = 0xa54ff53a;
    ms->h[4] = 0x510e527f;
    ms->h[5] = 0x9b05688c;
    ms->h[6] = 0x1f83d9ab;
    ms->h[7] = 0x5be0cd19;
    
    // Block header å‰ 64 bytes
    BYTE first_chunk[64];
    memcpy(first_chunk, block, 64);
    
    // è™•ç†ç¬¬ä¸€å€‹ chunk (CPU ç‰ˆæœ¬)
    SHA256 ctx;
    memcpy(ctx.h, ms->h, sizeof(ms->h));
    sha256_transform(&ctx, first_chunk);
    memcpy(ms->h, ctx.h, sizeof(ms->h));
    
    // æº–å‚™ç¬¬äºŒå€‹ chunk æ¨¡æ¿ (16 bytes data + 48 bytes padding)
    memset(ms->buffer, 0, 64);
    memcpy(ms->buffer, ((BYTE*)block) + 64, 16);  // å‰©é¤˜ 16 bytes (å« nonce)
    ms->buffer[16] = 0x80;  // Paddingé–‹å§‹
    // Length = 80 bytes = 640 bits
    ms->buffer[62] = 0x02;  // 640 bits = 0x0280
    ms->buffer[63] = 0x80;
    ms->buffer_len = 64;
}

void solve(FILE *fin, FILE *fout)
{
    char version[9], prevhash[65], ntime[9], nbits[9];
    int tx;
    char *raw_merkle_branch;
    char **merkle_branch;

    getline(version, 9, fin);
    getline(prevhash, 65, fin);
    getline(ntime, 9, fin);
    getline(nbits, 9, fin);
    fscanf(fin, "%d\n", &tx);

    raw_merkle_branch = new char [tx * 65];
    merkle_branch = new char *[tx];
    for(int i=0;i<tx;++i)
    {
        merkle_branch[i] = raw_merkle_branch + i * 65;
        getline(merkle_branch[i], 65, fin);
        merkle_branch[i][64] = '\0';
    }

    unsigned char merkle_root[32];
    calc_merkle_root(merkle_root, tx, merkle_branch);

    printf("merkle root(little): ");
    print_hex(merkle_root, 32);
    printf("\n");

    HashBlock block;
    convert_string_to_little_endian_bytes((unsigned char *)&block.version, version, 8);
    convert_string_to_little_endian_bytes(block.prevhash, prevhash, 64);
    memcpy(block.merkle_root, merkle_root, 32);
    convert_string_to_little_endian_bytes((unsigned char *)&block.nbits, nbits, 8);
    convert_string_to_little_endian_bytes((unsigned char *)&block.ntime, ntime, 8);
    block.nonce = 0;

    unsigned int exp = block.nbits >> 24;
    unsigned int mant = block.nbits & 0xffffff;
    unsigned char target_hex[32] = {};
    
    unsigned int shift = 8 * (exp - 3);
    unsigned int sb = shift / 8;
    unsigned int rb = shift % 8;
    
    target_hex[sb    ] = (mant << rb);
    target_hex[sb + 1] = (mant >> (8-rb));
    target_hex[sb + 2] = (mant >> (16-rb));
    target_hex[sb + 3] = (mant >> (24-rb));

    printf("Target value (big): ");
    print_hex_inverse(target_hex, 32);
    printf("\n");

    // è¨ˆç®—ä¸­é–“ç‹€æ…‹
    Midstate midstate;
    compute_midstate(&midstate, &block);
    
    printf("âœ¨ Midstate computed - 60%% speedup enabled!\n");

    // GPU é…ç½®
    cudaDeviceProp prop;
    cudaGetDeviceProperties(&prop, 0);
    
    int threadsPerBlock = 256;
    int maxBlocks = prop.multiProcessorCount * 8;  // æ¯å€‹ SM 8 å€‹ block
    int blocksPerGrid = min(maxBlocks, 4096);
    
    printf("GPU: %s (%d SMs)\n", prop.name, prop.multiProcessorCount);
    printf("Config: %d blocks Ã— %d threads = %d parallel\n", 
           blocksPerGrid, threadsPerBlock, blocksPerGrid * threadsPerBlock);

    // åˆ†é…è¨˜æ†¶é«”
    WORD *d_midstate;
    BYTE *d_second_chunk;
    unsigned char *d_target;
    unsigned int *d_found_nonce;
    int *d_found_flag;
    
    unsigned int *h_found_nonce;
    int *h_found_flag;
    cudaMallocHost(&h_found_nonce, sizeof(unsigned int));
    cudaMallocHost(&h_found_flag, sizeof(int));
    *h_found_flag = 0;
    
    cudaMalloc(&d_midstate, 8 * sizeof(WORD));
    cudaMalloc(&d_second_chunk, 64);
    cudaMalloc(&d_target, 32);
    cudaMalloc(&d_found_nonce, sizeof(unsigned int));
    cudaMalloc(&d_found_flag, sizeof(int));
    
    cudaMemcpy(d_midstate, midstate.h, 8 * sizeof(WORD), cudaMemcpyHostToDevice);
    cudaMemcpy(d_second_chunk, midstate.buffer, 64, cudaMemcpyHostToDevice);
    cudaMemcpy(d_target, target_hex, 32, cudaMemcpyHostToDevice);
    cudaMemcpy(d_found_flag, h_found_flag, sizeof(int), cudaMemcpyHostToDevice);
    
    unsigned int batch_size = 200000000;  // 200M nonces/batch
    unsigned int start_nonce = 0;
    
    printf("ğŸš€ Mining with ULTIMATE optimization...\n");
    
    cudaEvent_t start_event, stop_event;
    cudaEventCreate(&start_event);
    cudaEventCreate(&stop_event);
    cudaEventRecord(start_event);
    
    unsigned long long total_hashes = 0;
    
    while(start_nonce <= 0xffffffff && !(*h_found_flag))
    {
        unsigned int remaining = 0xffffffff - start_nonce + 1;
        unsigned int current_batch = (remaining < batch_size) ? remaining : batch_size;
        
        find_nonce_ultimate_kernel<<<blocksPerGrid, threadsPerBlock>>>(
            d_midstate, d_second_chunk, d_target, 
            d_found_nonce, d_found_flag,
            start_nonce, current_batch
        );
        
        total_hashes += current_batch;
        
        // æ¯ 10 æ‰¹æ¬¡æª¢æŸ¥ä¸€æ¬¡
        if((start_nonce / batch_size) % 10 == 0)
        {
            cudaMemcpy(h_found_flag, d_found_flag, sizeof(int), cudaMemcpyDeviceToHost);
            if(*h_found_flag)
            {
                cudaMemcpy(h_found_nonce, d_found_nonce, sizeof(unsigned int), cudaMemcpyDeviceToHost);
                break;
            }
        }
        
        if(start_nonce % 1000000000 == 0 && start_nonce > 0)
        {
            cudaEventRecord(stop_event);
            cudaEventSynchronize(stop_event);
            float ms = 0;
            cudaEventElapsedTime(&ms, start_event, stop_event);
            float hashrate = total_hashes / (ms / 1000.0) / 1e6;
            printf("Progress: %u (%.1f MH/s)\n", start_nonce, hashrate);
            
            total_hashes = 0;
            cudaEventRecord(start_event);
        }
        
        if(start_nonce > 0xffffffff - batch_size) break;
        start_nonce += batch_size;
    }
    
    cudaMemcpy(h_found_flag, d_found_flag, sizeof(int), cudaMemcpyDeviceToHost);
    if(*h_found_flag)
        cudaMemcpy(h_found_nonce, d_found_nonce, sizeof(unsigned int), cudaMemcpyDeviceToHost);
    
    block.nonce = *h_found_nonce;
    SHA256 sha256_ctx;
    double_sha256(&sha256_ctx, (unsigned char*)&block, sizeof(block));
    
    printf("\nâœ… Solution found!\n");
    printf("nonce: %u (0x%08x)\n", block.nonce, block.nonce);
    printf("hash(big): ");
    print_hex_inverse(sha256_ctx.b, 32);
    printf("\n\n");

    for(int i=0;i<4;++i)
        fprintf(fout, "%02x", ((unsigned char*)&block.nonce)[i]);
    fprintf(fout, "\n");

    cudaFree(d_midstate);
    cudaFree(d_second_chunk);
    cudaFree(d_target);
    cudaFree(d_found_nonce);
    cudaFree(d_found_flag);
    cudaFreeHost(h_found_nonce);
    cudaFreeHost(h_found_flag);
    cudaEventDestroy(start_event);
    cudaEventDestroy(stop_event);

    delete[] raw_merkle_branch;
    delete[] merkle_branch;
}

int main(int argc, char *argv[])
{
    if(argc != 3)
    {
        printf("usage: hw4 <in> <out>\n");
        return 1;
    }

    FILE *fin = fopen(argv[1], "r");
    FILE *fout = fopen(argv[2], "w");

    if(!fin || !fout)
    {
        fprintf(stderr, "Error opening files\n");
        return 1;
    }

    int totalblock;
    fscanf(fin, "%d\n", &totalblock);
    fprintf(fout, "%d\n", totalblock);

    for(int i=0;i<totalblock;++i)
    {
        printf("\n=== Block %d/%d ===\n", i+1, totalblock);
        solve(fin, fout);
    }

    fclose(fin);
    fclose(fout);
    return 0;
}
